# Linked Data and related system architectures

Above I mentioned that this dissertation studies how data interoperability can be start to be tackled in practice with Linked Data technologies. But what are Linked Data technologies and how do they work? In this section, I provide a brief overview of the main concepts and system architectures built for Linked Data technologies.

The term *Linked Data* was coined by Tim Berners-Lee, the inventor of the World Wide Web, in 2006 when he published a design note on the W3C website[^fn15], outlining a set of guidelines for publishing and connecting structured data on the Web, as part of his broader vision for the Semantic Web [@@Berners-Lee_SA_2001]. In essence, the Semantic Web is the vision of a more *machine-understandable* Web and Linked Data are the set of best practices for data to be *machine-understandable*. Berners-Lee defined four principles to create and publish Linked Data:

1. *Use URIs as names of things*: A uniform resource identifier (URI) is a string of characters that serves as a unique identifier for various types of things, including digital content, tangible objects, or abstract concepts. URIs enable to differentiate between different entities while also recognizing those that are the same. For instance, an entity may have different names in different languages, but its URI remains constant. To ensure the continuity of its meaning, a URI needs to be persistent, meaning it is permanently associated with a specific resource.

2. *Use HTTP URIs so that people can look up those names*: Linked Data commits to use the HTTP protocol to allow data sources to be accessed using generic data applications such as browsers, search engines, etc.

3. *When someone looks up a URI, provide useful information, using the standards (RDF and SPARQL)*: Linked Data entails publishing machine-readable and easy to interlink data. It is then crucial to use a standard format to represent the data and to use a standard query (search) language. The W3C recommendations RDF and SPARQL fulfill this role as standard solutions.

4. *Include links to other URIs to discover more things*: URIs guarantee entity identifiers to remain globally unique. This enables hyperlinks to be set between entities in different data sources. These (RDF) links connect all Linked Data into a single global data graph and enable applications to discover new data sources on the fly.

The above principles rely mainly on the existing technologies of the Web such as and HTTP . However, instead of using HTML as in regular websites intended for humans, Linked Data relies on the Resource Description Framework (RDF) to represent data for machines. RDF is a graph-based model for representing information on the Web[^fn16]. It is based on the idea of making statements about resources in the form of subject-predicate-object expressions. These expressions are known as triples in RDF terminology and are used to represent the relationships between entities. For example, the fact that the architect of the Ghent Sint-Pieters railway station was Louis Cloquet, may be represented in RDF as follows: `<Ghent-Sint-Pieters> <architect> <Louis Cloquet>`. In this example, `<Ghent-Sint-Pieters>` is the subject, `<architect>` is the predicate, and `<Louis Cloquet>` is the object of the triple. However, for this to be an actual RDF triple, each of the elements must be a URI (or a literal), as follows:

```turtle
<http://www.wikidata.org/entity/Q800814> # Ghent Sint-Pieters
<http://www.wikidata.org/property/P84> # architect
<http://www.wikidata.org/entity/Q2673824> # Louis Cloquet
```

The above URIs conform an actual triple from Wikidata and can be used to retrieve more information about the entities by dereferencing the URIs, as defined in the Linked Data principles. By using URIs , each entity can be uniquely identified on the Web, and by sharing these identifiers among systems, interconnection of data and interoperability can be made possible. Usually, among the information that can be found by dereferencing a Linked Data entity URI , are the definition of the entity type (a.k.a. class) and the properties that describe the entity. This information is commonly referred to as the semantic definition of the entity or its ontology. The W3C recommends a specification for defining ontologies called the Web Ontology Language (OWL)[^fn17]. OWL provides a rich set of constructs to define classes, properties, and relationships between entities. It also allows to define axioms and constraints that can be used to infer new knowledge from existing data.

A collection of RDF triples forms what is commonly called an RDF graph, which can be queried using the SPARQL query language[^fn18]. The SPARQL acronym refers to two distinct concepts: the SPARQL Language and the SPARQL protocol. The former defines an SQL-like syntax and formal algebra of a declarative language for querying RDF graphs. The latter defines a protocol for requesting the execution of SPARQL queries to remote HTTP servers. The most basic construct in SPARQL is known as a basic graph pattern (BGP), which is used to match a (sub)set of triples in one or more RDF graphs. Just like an RDF triple, a BGP is also composed of `subject-predicate-object` expressions, with the difference that any of the terms can be a variable/wildcard. The SPARQL language also offers several additional constructs that make it very expressive. These include optional patterns, filters, unions, negation, aggregation and sub-queries, among others. A unique characteristic of SPARQL is the capacity to define federated queries, which allow querying multiple RDF graphs distributed over the Web.

The publishing of Linked Data and the creation of applications able to consume it, have been traditionally supported by certain system architectural patterns. Heat et al. [@@Heath_MC_2011] identified three main patterns for Linked Data applications:

1. *Crawling-based architectures*: This pattern is based on the idea of crawling the Web to discover and index Linked Data sources.The Linked Data is then stored in a central repository and indexed to enable efficient querying. However, this pattern may cause that applications end up working with outdated data in between crawling processes.

2. *On-the-fly dereferencing architectures*: An application following this pattern, would recursively dereference URIs when the application requires data, which contrasts with the stale data access of the crawling pattern since retrieved data will always be fresh. However, this comes at the cost of performance.

3. *Query federation architectures*: This pattern is based on the idea of sending (parts of) a query to multiple SPARQL sources thus avoiding the need of having to copy locally remote RDF data. However, besides requiring the existence of SPARQL interfaces, federation approaches also face scalability issues when the number of sources increases.

Many works can be found in the literature that subscribe to one or more of the above architectural patterns. For instance, de Souza et al. [@@Souza_WE_2011] introduce SHDM, a framework to create Linked Data applications based on a general Model-View-Controller pattern that performs an initial Linked Data crawling and also supports query federation by means of underlying SPARQL implementations such as Apache Jena[^fn19]. Tran et al. [@@Tran_ISWC_2007] define an generic architecture for creating applications to manage the complete life cycle of ontologies, that is based on Service-Oriented Architecture (SOA) paradigm. Similarly, Vettor et al. [@@Vettor_ISSOSS_2014] also based their proposal on the SOA paradigm to define a generic architecture for Linked Data integration applications. Schwarte et al. [@@Schwarte_ISWC_2011] introduced FedX, a SPARQL query federation approach that uses optimisation techniques to efficiently handle BGP joins across distributed RDF graphs. Hartig et al. [@@Hartig_ISWC_2009] and later Taelman et al. [@@Taelman_ISWC_2023] propose on-the-fly dereferencing architectures based on linked traversal query processing approaches. Taelman et al. [@@Taelman_ISWC_2023] extend the approach of Hartig et al. [@@Hartig_ISWC_2009] and propose the use of predefined structural properties over decentralised environments to optimise the querying process in the presence of large number of data sources. They show that is feasible to scale on-the-fly dereferencing architectures, although only under specific conditions.

Other types of architectures focus on bringing support for the data writing aspect for Linked Data systems. That is the case of the W3C recommendation called Linked Data Platform (LDP)[^fn20]. LDP defines a read and write HTTP interface for Linked Data that closely resembles the design of REST APIs [@@Fielding_2000]. LDP introduces additional concepts beyond the Linked Data principles such as containers and writing capabilities [@@Nandana_ICCLD_2013], however it is mainly focused on providing consistent reading and writing of Linked Data resources and not on providing a reliable, efficient and/or expressive querying interface.

Overall, the literature over Linked Data architectures show a strong research tendency, with a few exceptions, to focus mainly on data that is or at least can be centralised. Most Linked Data applications rely on data that is gathered in an RDF data store which has been designed for efficient query processing [@@Ali_VLDB_2022]. In this dissertation, I study how Linked Data technologies can start tackling the data interoperability challenge in the transport domain and therefore it will focus mainly on architectural designs that enable decentralised data access for applications. This means that applications may have the ability to autonomously access and process themselves, i.e., perform their own query processes over data from distributed sources, similar to the on-the-fly dereferencing architectures described above. However, differing from query federation approaches, where the query processing is still centrally managed by a server and require data to be published via SPARQL endpoints to be able to query the data.

[^fn15]: <https://www.w3.org/DesignIssues/LinkedData.html>
[^fn16]: <http://www.w3.org/TR/rdf11-concepts/>
[^fn17]: <https://www.w3.org/TR/owl2-overview/>
[^fn18]: <https://www.w3.org/TR/sparql11-query/>
[^fn19]: <https://jena.apache.org/>
[^fn20]: <https://www.w3.org/TR/ldp/>
